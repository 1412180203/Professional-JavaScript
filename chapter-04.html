<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>chapter04</title>
	<link rel="stylesheet" href="css/main.css" />
</head>
<body>
	<h1>第4章 变量、作用域和内存问题</h1>
	<h2>4.1 基本类型和引用类型的值</h2>
	<p>
		ECMAScript 变量可能包含两种不同数据类型的值:基本类型值和引用类型值。<br />基本类型值指的是简单的数据段，包括：Undefined、Null、Boolean、Number 和 String。 这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br />
		引用类型值指那些可能由多个值构成的对象。JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。
	</p>
	<h3>1. 动态属性</h3>
	<p>
		对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。
	</p>
	<h3>2. 复制变量值</h3>
	<p>
		如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。此后，这两个变量可以参与任何操作而不会相互影响。 
	</p>
	<code>
		var num1 = 5;<br />
		var num2 = num1;
	</code><br />
	<img src="img/p4-1.png" alt="复制基本类型" />
	<p>
		当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的剧本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。 因此，改变其中一个变量，就会影响另一个变量。
	</p>
	<code>
		var obj1 = new Object();<br />
		var obj2 = obj1;<br />
		obj1.name = "Bob";<br />
		alert(obj2.name); //"Bob"
	</code><br />
	<img src="img/p4-2.png" alt="复制引用类型" />
	<h3>3. 传递参数</h3>
	<p>
		ECMAScript 中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型的值时， 会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。
	</p>
	<h3>4. 检测类型</h3>
	<p>
		typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变量的值是一个对象或 null，则 typeof 操作符会返回 "object"。<br />
		通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript 提供了 instanceof 操作符，其语法如下所示:
	</p>
	<code>
		var result = <var>variable</var> instanceof <var>constructor</var>
	</code>
	<p>
		如果变量是给定引用类型，那么 instanceof 操作符就会返回 true。根据规定，所有引用类型的值都是 Object 的实例。
	</p>
	<h2>4.2 执行环境及作用域</h2>
	<p>
		执行环境（有时也称为"环境"）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。<br />
		全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br />
		每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 
	</p>
	<p>
		当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
	</p>
	<code>
		var color = "blue";<br />
		<br />
		function changeColor() {<br />
		&nbsp;&emsp;&emsp;var anotherColor = "red";<br />
		<br />
		&nbsp;&emsp;&emsp;function swapColors() {<br />
		&nbsp;&emsp;&emsp;&nbsp;&emsp;&emsp;var tempColor = anotherColor;<br />
		&nbsp;&emsp;&emsp;&nbsp;&emsp;&emsp;anotherColor = color;<br />
		&nbsp;&emsp;&emsp;&nbsp;&emsp;&emsp;color = tempColor;<br />
		&nbsp;&emsp;&emsp;&nbsp;&emsp;&emsp;// 这里可以访问 color、anotherColor 和 tempColor<br />
		&nbsp;&emsp;&emsp;}<br />
		&nbsp;&emsp;&emsp;// 这里可以访问 color 和 anotherColor，但不能访问 tempColor<br />
		&nbsp;&emsp;&emsp;swapColors();<br />
		}<br />
		// 这里只能访问 color<br />
		changeColor();
	</code><br />
	<img src="img/p4-3.png" alt="作用域链" />
	<p>
		上图中的矩形表示特定的执行环境，其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名;但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。
	</p>
	<h4>(1) 延长作用域链</h4>
	<p>
		try-catch 语句的 catch 块，和 with 语句，这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
	</p>
	<h4>(2) 没有块级作用域</h4>
	<p>
		使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境;在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。
	</p>
	<h2>小结</h2>
	<p>
		JavaScript 变量可以用来保存两种类型的值:基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型: Undefined、Null、Boolean、Number 和 String。基本类型值和引用类型值具有以下特点:
	</p>
	<ul>
		<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;</li>
		<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;</li>
		<li>引用类型的值是对象，保存在堆内存中;</li>
		<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;</li>
		<li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象;</li>
		<li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</li>
	</ul>
	<p>
		所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变是。以下是关于执行环境的几点总结:
	</p>
	<ul>
		<li>执行环境有全局执行环境(也称为全局环境)和函数执行环境之分;</li>
		<li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链;</li>
		<li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全局环境;</li>
		<li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;</li>
		<li>变量的执行环境有助于确定应该何时释放内存。</li>
	</ul>
	<p>
		解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
	</p>
</body>
</html>